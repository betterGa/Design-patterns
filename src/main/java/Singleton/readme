单例 (Singleton)模式

要保证系统中 一个类最多只能存在一个实例 。
这种情况在应用中经常遇到，比如：缓存池、数据库连接池、线程池、一些应用服务实例等。

为了限制 该类的对象 被随意创建，需要保证 该类构造方法 是私有的  这样外部类就无法创建该类的对象了。
另外，为了方便给客户对象 提供 对此到哪里对象的使用 ，我们为它提供了一个全局访问点。

JVM加载类时，static 属性的变量 的初始化只能由一个线程执行且只能执行一次.

如果希望延迟实例化单例对象，只有在第一次使用该类的实例时，才去实例化：
  需要把 单例的实例化过程移到 getInstance() 方法中，而不是在加载类时预先创建。
  当访问此方法时，首先判断该实例是不是已经被实例化过了，如果已被初始化，则直接返回这个对象的引用；
                                                     否则，创建这个实例并初始化，再返回。

可以使 getInstance() 方法加 变成 synchronized 同步方法，实现多线程的安全访问，
但是 这样会降低性能，synchronized 对整个方法进行同步是没有必要的，
我们只要保证 实例化对象的那段逻辑被一个线程执行就可以了，而返回引用的那段代码 是没有必要同步的。
两次检测是否已被实例化，所以叫 double-checked locking模式

                     还有一种 Initialization on demand holder模式——延迟加载


Singleton 的序列化
  如果单例类 实现了 Serializable接口，这时要特别注意：
因为在默认情况下，每次反序列化总会创建一个新的实例对象。
