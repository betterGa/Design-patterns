工厂方法模式：
定义一个创建对象的接口，但由子类决定要实例化的类是哪一个。
工厂方法让类把实例化推迟到子类。

使用情景：
1.客户类不关心使用哪个具体类，只关心该接口所提供的功能。
2.创建过程比较复杂，例如需要初始化其他关联的资源类，读取配置文件等。
3.接口有很多具体实现类或者抽象类有很多具体子类时，可能需要为客户代码写一大串 if-else
  逻辑来决定运行时使用哪个具体实现或者具体子类。
4.不希望给客户程序暴露过多此类的内部结构，隐藏这些细节可以降低耦合度。
5.优化性能，比如缓存大对象或初始化比较耗时的对象。

应用:
  在 J2EE Web 应用中，由于
  每接收到一个 HTTP 请求时，就会启用一个线程来处理这个请求，
  使用 ThreadLocal 类很容易保证：
  在处理同一个请求的整个过程中，尽可能使用同一个数据库连接对象。

《Head First》 中的订购 Pizza 就是很好的例子

静态工厂方法：
  为每一个类创建一个工厂方法类会引起工厂类的泛滥，可以用静态工厂方法来避免。
  在每个类中实现一个静态的工厂方法，就不需要额外的工厂类了。比如  Integer 的 valueOf 方法里：

    public static Integer valueOf(int i) {
          if (i >= IntegerCache.low && i <= IntegerCache.high)
              return IntegerCache.cache[i + (-IntegerCache.low)];
          return new Integer(i);
      }

     如果在 -128~ 127 之间，就返回 IntegerCache 类缓存的 Integer 对象。

